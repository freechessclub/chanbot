<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="robots" content="noindex,nofollow">
<title>Channel Log</title>
<script src="https://cdn.jsdelivr.net/npm/autolink-js@1.0.2/autolink-min.min.js"></script>
<script type="text/javascript">
window.onload = function () {
    var items = [];
    var uniqueUsers = new Set(); // Track unique usernames
    var uniqueChannels = new Set(); // Track unique channels
    var userColors = {}; // Map users to colors
    const colors = [
        "#2B2D42", "#3D348B", "#6A0572", "#1B998B", "#E63946",
        "#8D8741", "#E3963E", "#457B9D", "#2A9D8F", "#4A4E69",
        "#5A189A", "#9D0208", "#283618", "#6B4226", "#3C1642",
        "#264653", "#7A4E4E", "#2C3E50", "#8F2D56", "#512D6D"
    ];
    const log = document.getElementById('log');
    const pagination = document.getElementById('pagination');
    const userFilters = document.getElementById('user-filters');
    const channelFilters = document.getElementById('channel-filters');
    const userCount = document.getElementById('user-count');
    const selectedCount = document.getElementById('selected-count');
    const channelCount = document.getElementById('channel-count');
    const selectedChannelCount = document.getElementById('selected-channel-count');
    const selectAllBtn = document.getElementById('select-all-users');
    const deselectAllBtn = document.getElementById('deselect-all-users');
    const selectAllChannelsBtn = document.getElementById('select-all-channels');
    const deselectAllChannelsBtn = document.getElementById('deselect-all-channels');
    const status = document.getElementById('status');
    let itemsPerPage = calculateItemsPerPage();
    let currPage = 0;
    const maxPages = 5;
    let countdownTimer = null;

    function assignColorToUser(user) {
        if (!userColors[user]) {
            const colorIndex = Object.keys(userColors).length % colors.length;
            userColors[user] = colors[colorIndex]; // Assign next available color
        }
        return userColors[user];
    }

    // Helper function to extract username from a message
    function extractUsername(message) {
        const match = message.match(/\(\d+\)\s+([^:]+):/);
        return match ? match[1] : null;
    }

    function extractChannel(message) {
        const match = message.match(/^\(([^)]+)\)\s+/);
        return match ? match[1] : null;
    }

    function escapeHtml(text) {
        const span = document.createElement('span');
        span.textContent = text;
        return span.innerHTML;
    }

    function updateUserPaneMeta() {
        const totalUsers = userFilters.querySelectorAll('input[type="checkbox"]').length;
        const activeUsers = userFilters.querySelectorAll('input[type="checkbox"]:checked').length;
        userCount.textContent = totalUsers;
        selectedCount.textContent = activeUsers + " selected";
    }

    function updateChannelPaneMeta() {
        const totalChannels = channelFilters.querySelectorAll('input[type="checkbox"]').length;
        const activeChannels = channelFilters.querySelectorAll('input[type="checkbox"]:checked').length;
        channelCount.textContent = totalChannels;
        selectedChannelCount.textContent = activeChannels + " selected";
    }

    // Create checkboxes for filtering by users
    function updateUserFilters() {
        const hadExistingFilters = userFilters.querySelectorAll('input').length > 0;
        const selectedUsers = new Set(
            Array.from(userFilters.querySelectorAll('input:checked')).map(checkbox => checkbox.value)
        );
        userFilters.innerHTML = '';
        const sortedUsers = Array.from(uniqueUsers).sort((a, b) => a.localeCompare(b));
        // Create checkboxes for each sorted user
        sortedUsers.forEach(user => {
            assignColorToUser(user); // Ensure every user has a color
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = hadExistingFilters ? selectedUsers.has(user) : true;
            checkbox.value = user;

            // Add event listener to reload the page's chat log when the checkbox is toggled
            checkbox.addEventListener('change', () => {
                updateUserPaneMeta();
                displayItems(currPage); // Reload the current page
            });
            // Display user name in their assigned color
            label.style.color = userColors[user];
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(user));
            userFilters.appendChild(label);
        });
        updateUserPaneMeta();
    }

    function updateChannelFilters() {
        const hadExistingFilters = channelFilters.querySelectorAll('input').length > 0;
        const selectedChannels = new Set(
            Array.from(channelFilters.querySelectorAll('input:checked')).map(checkbox => checkbox.value)
        );
        channelFilters.innerHTML = '';
        const sortedChannels = Array.from(uniqueChannels).sort((a, b) => {
            const aNum = Number(a);
            const bNum = Number(b);
            if (!Number.isNaN(aNum) && !Number.isNaN(bNum)) {
                return aNum - bNum;
            }
            return a.localeCompare(b);
        });

        sortedChannels.forEach(channel => {
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = hadExistingFilters ? selectedChannels.has(channel) : true;
            checkbox.value = channel;

            checkbox.addEventListener('change', () => {
                updateChannelPaneMeta();
                displayItems(currPage);
            });

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode("#" + channel));
            channelFilters.appendChild(label);
        });

        updateChannelPaneMeta();
    }

    function displayItems(pageNumber) {
        if (currPage != pageNumber) {
            return;
        }
        log.innerHTML = '';

        const selectedUsers = Array.from(userFilters.querySelectorAll('input:checked'))
            .map(checkbox => checkbox.value);
        const selectedChannels = Array.from(channelFilters.querySelectorAll('input:checked'))
            .map(checkbox => checkbox.value);

        if (selectedUsers.length === 0) {
            const emptyState = document.createElement('div');
            emptyState.className = 'empty-state';
            emptyState.textContent = 'No users selected. Choose 1+ users to view tells.';
            log.appendChild(emptyState);
            return;
        }

        if (selectedChannels.length === 0) {
            const emptyState = document.createElement('div');
            emptyState.className = 'empty-state';
            emptyState.textContent = 'No channels selected. Choose 1+ channels to view tells.';
            log.appendChild(emptyState);
            return;
        }

        const startIndex = (pageNumber - 1) * itemsPerPage;
        const endIndex = startIndex + itemsPerPage;

        const displayedItems = items.slice(startIndex, endIndex)
            .filter(item => {
                const username = extractUsername(item);
                const channel = extractChannel(item);
                return selectedUsers.includes(username) && selectedChannels.includes(channel);
            });

        displayedItems.forEach(item => {
            const username = extractUsername(item);
            const userColor = assignColorToUser(username);
            const div = document.createElement('div');
            div.className = 'log-item';
            const safeItem = escapeHtml(item);
            div.innerHTML = safeItem.autoLink({
                target: '_blank',
                rel: 'nofollow',
                callback: (url) => {
                    return /\.(gif|png|jpe?g)$/i.test(url)
                        ? `<a href="${url}" target="_blank" rel="nofollow"><img width="60" src="${url}"></a>`
                        : null;
                },
            });
            div.style.color = userColor; // Apply user-specific color
            var doScroll = log.scrollTop > log.scrollHeight - log.clientHeight - 1;
            log.appendChild(div);
            if (doScroll) {
                log.scrollTop = log.scrollHeight - log.clientHeight;
            }
        });
    }

    function calculateItemsPerPage() {
        const screenHeight = window.innerHeight;
        const itemHeight = 8;
        const itemsPerPage = Math.floor(screenHeight / itemHeight);
        return itemsPerPage;
    }

    function createPaginationButtons() {
        pagination.innerHTML = '';
        const numPages = Math.ceil(items.length / itemsPerPage);
        const showPages = Math.min(numPages, maxPages);
        const startPage = Math.max(1, numPages - showPages + 1);
        for (let i = 1; i <= showPages; i++) {
            const pageNumber = startPage + i - 1;
            const button = document.createElement('button');
            if (pageNumber === currPage) {
                button.classList.add('active');
                button.disabled = true;
            }
            button.textContent = pageNumber;
            button.addEventListener('click', function () {
                const buttons = pagination.querySelectorAll('button');
                buttons.forEach(btn => {
                    btn.classList.remove('active');
                    btn.disabled = false;
                });

                button.classList.add('active');
                button.disabled = true;
                currPage = pageNumber;
                displayItems(currPage);
            });
            pagination.appendChild(button);
        }
    }

    if (window["WebSocket"]) {
        var connClosed = false;

        function startCountdown() {
            if (countdownTimer) {
                clearInterval(countdownTimer);
            }
            let count = 5;
            status.textContent = "Reloading in " + count + " seconds...";
            countdownTimer = setInterval(() => {
                if (connClosed) {
                    clearInterval(countdownTimer);
                    countdownTimer = null;
                    return;
                }
                count--;
                status.textContent = "Reloading in " + count + " seconds...";

                if (count <= 0) {
                    clearInterval(countdownTimer);
                    countdownTimer = null;
                    status.textContent = '';
                }
            }, 1000);
        }
        startCountdown();

        const wsProtocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        var conn = new WebSocket(wsProtocol + document.location.host + "/ws");
        conn.onclose = function (evt) {
            connClosed = true;
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }
            status.innerHTML = "Connection closed.";
        };
        conn.onmessage = function (evt) {
            connClosed = false;
            const messages = evt.data.split('\n').filter(message => message.trim() !== '');
            if (messages.length === 0) {
                return;
            }
            items = items.concat(messages);
            messages.forEach(message => {
                const channel = extractChannel(message);
                const username = extractUsername(message);
                if (channel) uniqueChannels.add(channel);
                if (username) uniqueUsers.add(username);
            });
            updateUserFilters();
            updateChannelFilters();
            const numPagesBefore = Math.ceil((items.length - 1) / itemsPerPage);
            const numPagesAfter = Math.ceil(items.length / itemsPerPage);
            if (!currPage || numPagesAfter > numPagesBefore) {
                currPage = numPagesAfter;
                createPaginationButtons();
            }
            displayItems(numPagesAfter);
            startCountdown();
        };

          // Search function
        document.getElementById('search').addEventListener('input', function() {
            const searchText = this.value.toLowerCase();
            const divs = document.getElementById('log').getElementsByTagName('div');

            Array.from(divs).forEach(div => {
                if (div.textContent.toLowerCase().indexOf(searchText) > -1) {
                    div.classList.remove('hidden');
                } else {
                    div.classList.add('hidden');
                }
            });
        });

    } else {
        status.innerHTML = "Your browser does not support WebSockets.";
    }

    // Toggle user-pane visibility on mobile
    const menuToggle = document.getElementById('menu-toggle');
    const userPane = document.getElementById('user-pane');
    menuToggle.addEventListener('click', () => {
        const isVisible = userPane.style.display === 'block';
        userPane.style.display = isVisible ? 'none' : 'block';
    });

    selectAllBtn.addEventListener('click', () => {
        const checkboxes = userFilters.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = true;
        });
        updateUserPaneMeta();
        displayItems(currPage);
    });

    deselectAllBtn.addEventListener('click', () => {
        const checkboxes = userFilters.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        updateUserPaneMeta();
        displayItems(currPage);
    });

    selectAllChannelsBtn.addEventListener('click', () => {
        const checkboxes = channelFilters.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = true;
        });
        updateChannelPaneMeta();
        displayItems(currPage);
    });

    deselectAllChannelsBtn.addEventListener('click', () => {
        const checkboxes = channelFilters.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        updateChannelPaneMeta();
        displayItems(currPage);
    });

    // Theme toggle functionality
    const themeToggle = document.getElementById('theme-toggle');
    themeToggle.addEventListener('click', () => {
        document.body.classList.toggle('dark');
        const isDark = document.body.classList.contains('dark');
        themeToggle.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
    });
};

</script>
<link rel="stylesheet" href="/css/style.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lexend:wght@100..900&display=swap" rel="stylesheet">
</head>
<body>
<div id="container">
    <div id="status-bar">
        <div id="status"></div>
        <label for="search">Search: </label>
        <input type="text" id="search">
        <button id="theme-toggle" aria-label="Toggle Theme">üåô</button>
        <button id="menu-toggle" aria-label="Toggle User Pane">‚ò∞</button>
    </div>
    <!-- Main Content: Log and User Pane -->
    <div id="content">
        <div id="log"></div>
        <div id="user-pane">
            <div class="filter-section">
                <div class="filter-section-header">
                    <div class="filter-section-title">Channels (<span id="channel-count">0</span>)</div>
                    <div id="selected-channel-count">0 selected</div>
                </div>
                <div class="filter-actions">
                    <button id="select-all-channels" type="button">Select all</button>
                    <button id="deselect-all-channels" type="button">Deselect all</button>
                </div>
                <div id="channel-filters"></div>
            </div>
            <div class="filter-section">
                <div class="filter-section-header">
                    <div class="filter-section-title">Users (<span id="user-count">0</span>)</div>
                    <div id="selected-count">0 selected</div>
                </div>
                <div class="filter-actions">
                    <button id="select-all-users" type="button">Select all</button>
                    <button id="deselect-all-users" type="button">Deselect all</button>
                </div>
                <div id="user-filters">
                    <!-- User checkboxes will be dynamically added here -->
                </div>
            </div>
        </div>
    </div>
    <!-- Pagination -->
    <div id="pagination"></div>
</div>
</body>
</html>
